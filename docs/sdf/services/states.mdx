---
sidebar_position: 4
title: "States"
description: Stateful Dataflows states definition
slug: /sdf/states
---

# State Processing

State processing is a mechanism that facilitates the collection and retrieval of data generated by streams of records. With states, dataflows can build tables, compute aggregates, join datasets, perform anomaly detections, and execute any other operation that requires collections of records.

States are specified in the services section, where each state is designated with one owner/writer but can have multiple readers.

Fluvio supports two types of states:

* [Key/Value](#keyvalue-states) - the value has `primitive` types.
* [Table](#table-states) - the value has `arrow` type.

These states can be referenced across services to look-up values or perform composite operations like joins. Check out [Ref State](#ref-state) below for details.


## Key/Value States

A simple state has a `key` defining the partition and a `value` for saving the object. The following example shows a state object where the value is a 32 bit unsigned integer.

```yaml
transforms:
   states:
    - name: count-per-word
      type: keyed-state
      properties:
        key:
            type: string
        value:
            type: u32
```


The states are accessed through functions. For example to increment the value of `count-per-word`, we define an operator that reads `count_per_word` and updates the value. Then you can perform `increment` , `set`, `get` operation on the state:

```yaml
- operator: map
  run: |
    fn increment_word_count(word: String) -> Result<WordCount, String> {
      let counter = count_per_word();
      let value = counter.increment(1);

      Ok(WordCount {
        word: word,
        count: value as u32,
      })
    }
```

In this example, we used `increment` to add one to the previous value.


## Table States

The table state has a partition `key` and a value of `arrow-row` type. The arrow type may look familiar, as it is a mapping of the [arrow dataframe type]. These dataframes are portable with several full features libraries such as [Polars]. Fluvio uses adapters to map dataframes with with a these libraries.

```yaml
transforms:
  states:
    - name: temperature
      type: keyed-state
      properties:
        key:
          type: string
        value:
          type: arrow-row
          properties:
            sensor:
              type: string
            temperature:
              type: f32
```

The `assign-key` and `update-state` operator to partition and populate the table with temperature events:

```yaml
steps:
  - operator: assign-key
    run: |
      fn key_by_id(event: Temp) -> Result<i32, String> {
        Ok(event.id)
      }

  - operator: update-state
    run: |
      fn update_temperature(event: Temp) -> Result<(), String> {
        let mut temp = temperature();

        temp.sensor = event.sensor;
        temp.temperature = event.temperature;
        temp.update();

        Ok(())
      }
```

Resulting in the following arrow representation:

| key  | sensor | temperature |
| ---- | ------ | ----------- |
|   0  | SF     | 54          |
|   1  | LA     | 38          |
|   3  | MO     | 27          |

Tabes are used for enrichment, join operations, annomaly detection, or are periodically flushed to topics to diplay in dashboards.


## Ref State

Reference (aka Ref) States allows services to query states owned by other services.  For example, a service interested in the temperature of a city, can query the temperature table managed by an external services.

The reference state is using keyword `from` as below:

```yaml
transforms:
  states:
    - name: temperature
      from: update-temperature.temperature
```

However, external eservices are not allowed to update states they do not own.


--------

### `states`

**States** are aggregate objects that accumulate data from the event streams. The state objects are defined by the users and maintained by the system. The system ensures the states object is durable and survives restarts.

States follow the [CQRS architecture], where each state has one writer and multiple readers.

##### State writer (command)

The states are defined inside the `transforms` block of a services as follows:

```yaml
car-colors-counter-service:
  transforms:

    states:
      car-color-state:
        type: key-value
        properties:
          key:
            type: string
          value:
            type: u32

    steps:
      ...
    ...
```

The states are `key-value` objects where the key and value can be arbitrary types. In this example, `key` is the car color and `value` is the number of cars of each color. The state object is updated by one of the functions the `steps`.

##### State reader (query)

The state can be read from any other service in the dataflow. To read the state it need to be referenced first:

```yaml
cars-prediction-service:
  transforms:

  states:
    car-color-state:
      from: bcar-colors-counter-service.car-color-state

  steps:
    ...
```

The `car-color-state` is now usable in any of the steps of the `cars-prediction-service`.

--------

[arrow dataframe type]: https://docs.rs/arrow/latest/arrow/
[Polars]: https://pola.rs/
[window operations]: /docs/sdf/operators#window-operators
